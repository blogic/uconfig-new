{%
	const QOS_CLASSES = {
		besteffort: { ingress: 'CS0', egress: 'CS0' },
		bulk: { ingress: 'LE', egress: 'LE' },
		video: { ingress: 'AF41', egress: 'AF41' },
		voice: {
			ingress: 'CS6',
			egress: 'CS6',
			bulk_trigger_pps: 100,
			bulk_trigger_timeout: 5,
			dscp_bulk: 'CS0'
		}
	};

	let qos_db = readjson('/usr/share/ucode/uconfig/qos.json');

	function interface_defaults_get(interface_config) {
		let bb_type = interface_config.broad_band?.type;

		return {
			overhead_type: (bb_type == 'pppoe') ? 'pppoe-ptm' : 'ethernet',
			ingress: '1',
			egress: '1',
			mode: 'diffserv4',
			nat: '1',
			host_isolate: '1',
			autorate_ingress: (bb_type == 'wwan') ? '1' : '0',
			ingress_options: '',
			egress_options: '',
			options: ''
		};
	}

	function is_upstream_interface(interface_config) {
		return interface_config.role === 'upstream';
	}

	function has_qos_bandwidth(interface_config) {
		let qos = interface_config.quality_of_service;

		return qos?.bandwidth_up && qos?.bandwidth_down;
	}

	function has_qos_interfaces() {
		for (let name, iface in state.interfaces)
			if (is_upstream_interface(iface) && has_qos_bandwidth(iface))
				return true;

		return false;
	}

	function generate_qos_defaults() {
		let output = [];
		let bulk = quality_of_service?.bulk_detection;
		let dscp_prio = bulk?.dscp ?? 'video';
		let prio_max_avg_pkt_len = bulk?.packets_per_second ?? 500;

		uci_comment(output, '# generated by quality-of-service.uc');
		uci_comment(output, '### generate qos defaults');
		uci_section(output, 'qosify defaults');
		uci_list_string(output, 'qosify.@defaults[-1].defaults', '/etc/qosify/*.conf');
		uci_set_string(output, 'qosify.@defaults[-1].dscp_prio', dscp_prio);
		uci_set_string(output, 'qosify.@defaults[-1].dscp_icmp', '+besteffort');
		uci_set_string(output, 'qosify.@defaults[-1].dscp_default_udp', 'besteffort');
		uci_set_number(output, 'qosify.@defaults[-1].prio_max_avg_pkt_len', prio_max_avg_pkt_len);

		return uci_output(output);
	}

	function generate_qos_classes() {
		let output = [];

		uci_comment(output, '### generate qos classes');

		for (let class_name, config in QOS_CLASSES) {
			uci_named_section(output, `qosify.${class_name}`, 'class');
			uci_set_string(output, `qosify.${class_name}.ingress`, config.ingress);
			uci_set_string(output, `qosify.${class_name}.egress`, config.egress);

			if (class_name === 'voice') {
				uci_set_number(output, `qosify.${class_name}.bulk_trigger_pps`, config.bulk_trigger_pps);
				uci_set_number(output, `qosify.${class_name}.bulk_trigger_timeout`, config.bulk_trigger_timeout);
				uci_set_string(output, `qosify.${class_name}.dscp_bulk`, config.dscp_bulk);
			}
		}

		return uci_output(output);
	}

	function generate_service_classes() {
		if (!qos_db?.classes)
			return '';

		let output = [];

		uci_comment(output, '### generate service qos classes');

		for (let name, cls in qos_db.classes) {
			uci_named_section(output, `qosify.${name}`, 'class');
			uci_set_string(output, `qosify.${name}.ingress`, cls.ingress);
			uci_set_string(output, `qosify.${name}.egress`, cls.egress);

			if (cls['bulk-pps'])
				uci_set_number(output, `qosify.${name}.bulk_trigger_pps`, cls['bulk-pps']);
			if (cls['bulk-timeout'])
				uci_set_number(output, `qosify.${name}.bulk_trigger_timeout`, cls['bulk-timeout']);
			if (cls['bulk-dscp'])
				uci_set_string(output, `qosify.${name}.dscp_bulk`, cls['bulk-dscp']);
		}

		return uci_output(output);
	}

	function collect_service_rules(rules) {
		let svc_list = quality_of_service?.services;

		if (!length(svc_list) || !qos_db?.services)
			return;

		let all = ('all' in svc_list);

		for (let k, v in qos_db.services)
			if (all || (k in svc_list))
				for (let dep in v.uses)
					push(svc_list, dep);

		for (let k, v in qos_db.services) {
			if (!all && !(k in svc_list))
				continue;

			for (let port in v.tcp)
				push(rules, `tcp:${port} ${v.classifier}`);
			for (let port in v.udp)
				push(rules, `udp:${port} ${v.classifier}`);
			for (let fqdn in v.fqdn)
				push(rules, `dns:${fqdn} ${v.classifier}`);
		}
	}

	function collect_classifier_rules(rules) {
		let classifiers = quality_of_service?.classifier;

		if (!length(classifiers))
			return;

		for (let entry in classifiers) {
			for (let port in entry.ports) {
				let protos = (port.protocol == 'any' || !port.protocol)
					? [ 'udp', 'tcp' ]
					: [ port.protocol ];
				let range = port.range_end ? `-${port.range_end}` : '';
				let prefix = port.reclassify === false ? '+' : '';

				for (let proto in protos)
					push(rules, `${proto}:${port.port}${range} ${prefix}${entry.dscp}`);
			}

			for (let fqdn in entry.dns) {
				let prefix = fqdn.reclassify === false ? '+' : '';
				let name = fqdn.suffix_matching !== false
					? `*.${fqdn.fqdn}`
					: fqdn.fqdn;
				push(rules, `dns:${name} ${prefix}${entry.dscp}`);
			}
		}
	}

	function generate_qosify_rules() {
		let rules = [];

		collect_service_rules(rules);
		collect_classifier_rules(rules);

		if (length(rules))
			files.add_named('/etc/qosify/uconfig.conf', join('\n', uniq(rules)) + '\n');
	}

	function generate_interface_qos(interface_name, interface_config) {
		if (!is_upstream_interface(interface_config) || !has_qos_bandwidth(interface_config))
			return '';

		let output = [];
		let qos = interface_config.quality_of_service;

		uci_comment(output, '### generate interface qos configuration');
		uci_named_section(output, `qosify.${interface_name}`, 'interface');
		uci_set_string(output, `qosify.${interface_name}.name`, interface_name);
		uci_set_string(output, `qosify.${interface_name}.bandwidth_up`, `${qos.bandwidth_up}mbit`);
		uci_set_string(output, `qosify.${interface_name}.bandwidth_down`, `${qos.bandwidth_down}mbit`);
		for (let key, value in interface_defaults_get(interface_config))
			uci_set_string(output, `qosify.${interface_name}.${key}`, value);

		return uci_output(output);
	}

	function generate_all_interface_qos() {
		let output = [];

		uci_comment(output, '### generate all interface qos configurations');

		for (let name, iface in state.interfaces) {
			let config = generate_interface_qos(name, iface);
			if (config)
				push(output, config);
		}

		return uci_output(output);
	}

	let enable_qos = has_qos_interfaces();
	services.set_enabled('qosify', enable_qos);

	if (!enable_qos)
		return;

	generate_qosify_rules();
%}

## Configure QOSIFY
{{ generate_qos_defaults() }}

{{ generate_qos_classes() }}

{{ generate_service_classes() }}

{{ generate_all_interface_qos() }}


{%
	// Constants
	const VALID_BANDS = [ '2G', '5G', '6G' ];
	const FALLBACK_MODES = {
		EHT: /^(EHT:HE|VHT|HT)/,
		HE: /^(HE|VHT|HT)/,
		VHT: /^(VHT|HT)/,
		HT: /^HT/
	};
	const MODE_WEIGHT = { HT: 1, VHT: 10, HE: 100, EHT: 1000 };
	const MODE_80_80_WEIGHT = 200;
	const REQUIRE_MODES = { HT: "n", VHT: "ac", HE: "ax", EHT: "be" };

	// is_ functions - boolean checks/validation
	function is_valid_band(band) {
		return band in VALID_BANDS;
	}

	function is_auto_channel(channel) {
		return !channel || channel == "auto";
	}

	function is_band(band, target_band) {
		return lc(band) == lc(target_band);
	}

	function is_allowed_channel(phy, radio) {
		if (radio.channel_width == 20)
			return true;

		let band_info = phy.bands?.[radio.band];
		if (!band_info)
			return false;

		let chan_info = filter(band_info.channels, c => c.channel == radio.channel)?.[0];
		if (!chan_info)
			return false;

		switch (radio.channel_width) {
		case 40:
			if (chan_info.no_ht40_minus && chan_info.no_ht40_plus)
				return false;
			break;
		case 80:
			if (chan_info.no_80mhz)
				return false;
			break;
		case 160:
			if (chan_info.no_160mhz)
				return false;
			break;
		case 320:
			if (chan_info.no_320mhz)
				return false;
			break;
		}

		if (radio.valid_channels && !(radio.channel in radio.valid_channels))
			return false;

		return true;
	}

	// match_ functions - value mapping/selection
	function calculate_mode_weight(mode) {
		let m = match(mode, /^([A-Z]+)(.+)$/);

		if (!m)
			return 0;

		let base_weight = MODE_WEIGHT[m[1]] || 0;
		let multiplier = (m[2] == "80+80") ? MODE_80_80_WEIGHT : +m[2];

		return base_weight * multiplier;
	}

	function get_supported_modes(phy, radio) {
		let modes = phy.bands[radio.band].modes;
		let weighted_modes = map(modes, (mode) => [mode, calculate_mode_weight(mode)]);
		let sorted_modes = sort(weighted_modes, (a, b) => (b[1] - a[1]));

		return map(sorted_modes, i => i[0]);
	}

	function filter_incompatible_modes(modes, radio) {
		return filter(modes, mode =>
			!(index(radio.band, "2G") >= 0 && mode == "VHT80"));
	}

	function find_fallback_mode(supported_modes, channel_mode, wanted_mode) {
		for (let supported_mode in supported_modes) {
			if (match(supported_mode, FALLBACK_MODES[channel_mode])) {
				warn("Selected radio does not support requested HT mode %s, falling back to %s",
					wanted_mode, supported_mode);
				return supported_mode;
			}
		}

		return null;
	}

	function match_htmode(phy, radio) {
		let channel_mode = radio.channel_mode;
		let channel_width = radio.channel_width;
		let wanted_mode = channel_mode + (channel_width == 8080 ? "80+80" : channel_width);

		let supported_modes = get_supported_modes(phy, radio);
		supported_modes = filter_incompatible_modes(supported_modes, radio);

		if (wanted_mode in supported_modes)
			return wanted_mode;

		let fallback_mode = find_fallback_mode(supported_modes, channel_mode, wanted_mode);
		if (fallback_mode) {
			delete radio.channel;
			return fallback_mode;
		}

		die("Selected radio does not support any HT modes");
	}

	function match_channel(phy, radio) {
		let wanted_channel = radio.channel;

		if (is_auto_channel(wanted_channel))
			return 0;

		if (!is_allowed_channel(phy, radio)) {
			warn("Selected radio does not support requested channel %d at width %d, falling back to ACS",
				wanted_channel, radio.channel_width);
			return 0;
		}

		return wanted_channel;
	}

	function match_require_mode(require_mode) {
		return REQUIRE_MODES[require_mode] || '';
	}

	// Configuration generation functions
	function generate_basic_config(phy, radio, htmode) {
		if (!phy || !radio)
			return '';

		let output = [];

		uci_comment(output, '# generated by radio.uc');
		uci_comment(output, '### generate basic radio config');
		uci_set_boolean(output, `wireless.${phy.section}.disabled`, false);
		uci_set_string(output, `wireless.${phy.section}.uconfig_path`, location);
		uci_set_string(output, `wireless.${phy.section}.htmode`, htmode);
		uci_set_number(output, `wireless.${phy.section}.channel`, match_channel(phy, radio));
		uci_set_string(output, `wireless.${phy.section}.country`, state.country_code);
		uci_set_string(output, `wireless.${phy.section}.require_mode`, match_require_mode(radio.require_mode));
		uci_set_number(output, `wireless.${phy.section}.txpower`, radio.tx_power);
		uci_set_boolean(output, `wireless.${phy.section}.legacy_rates`, radio.legacy_rates);
		uci_set_number(output, `wireless.${phy.section}.maxassoc`, radio.maximum_clients);
		uci_set_boolean(output, `wireless.${phy.section}.acs_exclude_dfs`, !radio.allow_dfs);
		uci_set_string(output, `wireless.${phy.section}.band`, lc(radio.band));

		return uci_output(output);
	}

	function generate_5g_config(phy, radio) {
		if (!is_band(radio.band, '5g'))
			return '';

		let output = [];

		uci_comment(output, '### generate 5G specific config');
		uci_set_boolean(output, `wireless.${phy.section}.background_radar`, true);

		return uci_output(output);
	}

	function generate_general_config(phy, radio) {
		if (!phy || !radio)
			return '';

		let output = [];

		uci_comment(output, '### generate general radio config');
		uci_set_boolean(output, `wireless.${phy.section}.noscan`, true);
		uci_set_boolean(output, `wireless.${phy.section}.reconf`, true);

		if (radio.allow_dfs && radio.valid_channels) {
			for (let channel in radio.valid_channels)
				uci_list_number(output, `wireless.${phy.section}.channels`, channel);
		}

		return uci_output(output);
	}

	function generate_he_config(phy, radio, htmode) {
		if (!radio.he_settings || !phy.he_mac_capa || !match(htmode, /HE.*/))
			return '';

		let output = [];

		uci_comment(output, '### generate HE settings config');
		uci_set_number(output, `wireless.${phy.section}.he_bss_color`, radio.he_settings.bss_color);
		uci_set_boolean(output, `wireless.${phy.section}.multiple_bssid`, radio.he_multiple_bssid);
		uci_set_boolean(output, `wireless.${phy.section}.ema`, radio.he_settings.ema);

		return uci_output(output);
	}

	function generate_rates_config(phy, radio) {
		if (!radio.rates)
			return '';

		let output = [];

		uci_comment(output, '### generate rates config');
		uci_set_number(output, `wireless.${phy.section}.basic_rate`, radio.rates.beacon);
		uci_set_number(output, `wireless.${phy.section}.mcast_rate`, radio.rates.multicast);

		return uci_output(output);
	}

	function generate_6g_config(phy, radio) {
		if (!is_band(radio.band, '6g'))
			return '';

		let output = [];

		uci_comment(output, '### generate 6G specific config');
		uci_set_boolean(output, `wireless.${phy.section}.he_co_locate`, true);

		return uci_output(output);
	}

	// Main logic and setup
	radio.phy = phy_name;
	if (!radio.band)
		radio.band = phy_name;

	if (!is_valid_band(radio.band)) {
		warn("Radio does not have a valid band");
		return;
	}

	let phys = wiphy.lookup(phy_name);

	if (!length(phys)) {
		warn("Can't find any suitable radio phy for band %s radio settings", radio.band);
		return;
	}

%}
{%	for (let phy in phys):
		let htmode = match_htmode(phy, radio) %}

## Basic radio configuration
{{ generate_basic_config(phy, radio, htmode) }}

## General settings
{{ generate_general_config(phy, radio) }}

## 5G configuration
{{ generate_5g_config(phy, radio) }}

## HE configuration
{{ generate_he_config(phy, radio, htmode) }}

## Rate settings
{{ generate_rates_config(phy, radio) }}

## 6G configuration
{{ generate_6g_config(phy, radio) }}
{% 	endfor %}


{%
	// Configuration generation functions
	function generate_bridge_vlan_config() {
		let output = [];

		uci_comment(output, '# generated by interface/bridge-vlan.uc');
		uci_comment(output, '### generate bridge-vlan configuration');
		uci_section(output, 'network bridge-vlan');
		uci_set_string(output, 'network.@bridge-vlan[-1].device', bridgedev);
		uci_set_number(output, 'network.@bridge-vlan[-1].vlan', this_vid);

		// Add all wired ports
		for (let port in keys(eth_ports))
			uci_list_string(output, 'network.@bridge-vlan[-1].ports',
				`${port}${ethernet.port_vlan(interface, eth_ports[port])}`);

		// Add batman interface if mesh support is enabled
		if (batman_adv) {
			let batman_port = 'batman' + (ethernet.has_vlan(interface) ? '.' + this_vid + ':t' : '');

			uci_list_string(output, 'network.@bridge-vlan[-1].ports', batman_port);
		}

		uci_set_boolean(output, 'network.@bridge-vlan[-1].isolate', interface.isolate_hosts);

		return uci_output(output);
	}

	function generate_vlan_device_config() {
		let output = [];

		uci_comment(output, '### generate VLAN device configuration');
		uci_section(output, 'network device');
		uci_set_string(output, 'network.@device[-1].type', '8021q');
		uci_set_string(output, 'network.@device[-1].name', netdev);
		uci_set_string(output, 'network.@device[-1].ifname', bridgedev);
		uci_set_number(output, 'network.@device[-1].vid', this_vid);
		uci_set_boolean(output, 'network.@device[-1].stp', true);

		return uci_output(output);
	}
%}

## Bridge VLAN configuration
{{ generate_bridge_vlan_config() }}

## VLAN device configuration
{{ generate_vlan_device_config() }}


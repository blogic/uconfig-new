{%
	// Constants
	const PROTOCOL_MODES = {
		static: 'static',
		dynamic_ipv4: 'dhcp',
		dynamic_ipv6: 'dhcpv6',
		none: 'none'
	};

	// is_ functions - boolean checks/validation
	function is_dual_stack(afnames) {
		return length(afnames) >= 2;
	}

	function is_static_mode(ipv4_mode, ipv6_mode) {
		return ipv4_mode == 'static' || ipv6_mode == 'static';
	}

	function is_downstream_with_vlan(interface) {
		return interface.role == "downstream" && ethernet.has_vlan(interface);
	}

	function is_ipv4_interface(ipv4_mode, afnames, afidx) {
		return ipv4_mode != 'none' && (length(afnames) == 1 || afidx == 0);
	}

	function is_ipv6_interface(ipv6_mode, afnames, afidx) {
		return ipv6_mode != 'none' && (length(afnames) == 1 || afidx == 1);
	}

	// match_ functions - value mapping/selection
	function match_protocol(ipv4_mode, ipv6_mode, afnames, afidx) {
		if (is_static_mode(ipv4_mode, ipv6_mode))
			return PROTOCOL_MODES.static;

		if ((length(afnames) == 1 || afidx == 0) && ipv4_mode == 'dynamic')
			return PROTOCOL_MODES.dynamic_ipv4;

		if ((length(afnames) == 1 || afidx == 1) && ipv6_mode == 'dynamic')
			return PROTOCOL_MODES.dynamic_ipv6;

		return PROTOCOL_MODES.none;
	}

	// Configuration generation functions
	function generate_dummy_interface(afnames) {
		if (!is_dual_stack(afnames))
			return '';

		let output = [];

		uci_comment(output, '# generated by interface/common.uc');
		uci_comment(output, '### generate dual-stack dummy interface');
		uci_named_section(output, `network.${name}`, 'interface');
		uci_set_string(output, `network.${name}.uconfig_name`, interface.name);
		uci_set_string(output, `network.${name}.uconfig_path`, location);
		uci_set_string(output, `network.${name}.device`, netdev);
		uci_set_number(output, `network.${name}.metric`, interface.metric);
		uci_set_string(output, `network.${name}.proto`, 'none');

		return uci_output(output);
	}

	function generate_interface_config(afname, afidx, afnames) {
		let output = [];

		uci_comment(output, '### generate interface configuration');
		uci_named_section(output, `network.${afname}`, 'interface');
		uci_set_string(output, `network.${afname}.uconfig_name`, interface.name);
		uci_set_string(output, `network.${afname}.uconfig_path`, location);
		uci_set_string(output, `network.${afname}.device`, netdev);
		uci_set_string(output, `network.${afname}.type`, interface.type);
		uci_set_string(output, `network.${afname}.proto`,
			match_protocol(ipv4_mode, ipv6_mode, afnames, afidx));

		return uci_output(output);
	}

	function generate_vlan_routing_rule(afname) {
		if (!is_downstream_with_vlan(interface))
			return '';

		let output = [];

		uci_comment(output, '### generate VLAN routing rule');
		uci_section(output, 'network rule');
		uci_set_string(output, 'network.@rule[-1].in', afname);
		uci_set_string(output, 'network.@rule[-1].lookup', routing_table.get(interface.vlan.id));

		return uci_output(output);
	}

	function generate_ipv4_config(afname, afnames, afidx) {
		if (!is_ipv4_interface(ipv4_mode, afnames, afidx))
			return '';

		include('ipv4.uc', { name: afname });

		return '';
	}

	function generate_ipv6_config(afname, afnames, afidx) {
		if (!is_ipv6_interface(ipv6_mode, afnames, afidx))
			return '';

		include('ipv6.uc', { name: afname });

		return '';
	}

	let afnames = ethernet.calculate_names(interface);
%}

## Dual-stack interface configuration
{{ generate_dummy_interface(afnames) }}

## Address family interfaces
{%	for (let afidx, afname in afnames): %}

### Interface {{ afname }}
{{ generate_interface_config(afname, afidx, afnames) }}
{{ generate_vlan_routing_rule(afname) }}
{{ generate_ipv4_config(afname, afnames, afidx) }}
{{ generate_ipv6_config(afname, afnames, afidx) }}

{%	endfor %}


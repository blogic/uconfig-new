{%
	// is_ functions - boolean checks/validation
	function is_upstream_interface(interface) {
		return interface.role == 'upstream';
	}

	// normalize_ functions - data transformation
	function normalize_port_name(port) {
		return replace(port, '.', '_');
	}

	// Configuration generation functions
	function generate_ieee8021x_port_config(port) {
		let output = [];

		uci_comment(output, '# generated by interface/ieee8021x.uc');
		uci_comment(output, '### generate IEEE 802.1X port configuration');
		uci_section(output, 'ieee8021x port');
		uci_set_string(output, 'ieee8021x.@port[-1].iface', port);
		uci_set_number(output, 'ieee8021x.@port[-1].vlan', this_vid);
		uci_set_boolean(output, 'ieee8021x.@port[-1].upstream', is_upstream_interface(interface));
		for (let eth_port in keys(eth_ports))
			uci_list_string(output, 'ieee8021x.@port[-1].wan_ports', eth_port);

		return uci_output(output);
	}

	function generate_network_device_config(port) {
		let nport = normalize_port_name(port);
		let output = [];

		uci_comment(output, '### generate network device configuration');
		uci_named_section(output, `network.${nport}`, 'device');
		uci_set_string(output, `network.${nport}.name`, port);
		uci_set_boolean(output, `network.${nport}.auth`, true);
		uci_set_string(output, `network.${nport}.auth_vlan`, `${interface.dot1x_vlan}:u`);

		return uci_output(output);
	}

	function generate_port_assignment(port) {
		let output = [];

		uci_comment(output, '### generate port assignment');
		if (is_upstream_interface(interface))
			uci_list_string(output, 'network.wan_bridge.ports', port);
		else
			uci_list_string(output, 'network.lan_bridge.ports', port);

		return uci_output(output);
	}
%}

{%	for (let port in dot1x_ports): %}
## IEEE 802.1X configuration for port {{ port }}
{{ generate_ieee8021x_port_config(port) }}

{{ generate_network_device_config(port) }}

{{ generate_port_assignment(port) }}

{%	endfor %}


{%
	// Helper functions
	function has_vlan_interface(interface) {
		return ethernet.has_vlan(interface);
	}

	// Configuration generation functions
	function generate_batman_master() {
		if (!batman_adv_master)
			return '';

		let output = [];

		uci_comment(output, '# generated by mesh-batman-adv.uc');
		uci_comment(output, '### generate batman master interface');
		uci_named_section(output, 'network.batman', 'interface');
		uci_set_string(output, 'network.batman.proto', 'batadv');
		uci_set_boolean(output, 'network.batman.multicast_mode', false);
		uci_set_boolean(output, 'network.batman.distributed_arp_table', false);
		uci_set_boolean(output, 'network.batman.bridge_loop_avoidance', true);
		uci_set_number(output, 'network.batman.orig_interval', 5000);

		return uci_output(output);
	}

	function generate_batman_vlan_interface(vid) {
		let output = [];

		uci_comment(output, '### generate batman vlan interface');
		uci_named_section(output, `network.batman_v${vid}`, 'interface');
		uci_set_string(output, `network.batman_v${vid}.proto`, 'batadv_vlan');
		uci_set_string(output, `network.batman_v${vid}.ifname`, `batman.${vid}`);

		return uci_output(output);
	}

	function generate_batman_hardif() {
		let output = [];

		uci_comment(output, '### generate batman hardif interface');
		uci_named_section(output, 'network.batman_mesh', 'interface');
		uci_set_string(output, 'network.batman_mesh.proto', 'batadv_hardif');
		uci_set_string(output, 'network.batman_mesh.master', 'batman');
		uci_set_number(output, 'network.batman_mesh.mtu', 1532);

		return uci_output(output);
	}

	function generate_batman_interface(interface, vid) {
		if (has_vlan_interface(interface))
			return generate_batman_vlan_interface(vid);
		else
			return generate_batman_hardif();
	}
%}
{{ generate_batman_master() }}

## Batman interface configuration
{{ generate_batman_interface(interface, this_vid) }}


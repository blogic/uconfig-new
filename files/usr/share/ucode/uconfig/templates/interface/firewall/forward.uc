
# generated by interface/firewall/forward.uc

{%
	// Constants
	const WILDCARD_PROTOCOLS = ['any', 'all', '*'];
	const DEFAULT_PROTOCOLS = ['tcp', 'udp'];

	// is_ functions - boolean checks/validation
	function is_wildcard_protocol(protocol) {
		return protocol in WILDCARD_PROTOCOLS;
	}

	// match_ functions - value mapping/selection
	function match_protocols(protocol) {
		return is_wildcard_protocol(protocol) ? DEFAULT_PROTOCOLS : [protocol];
	}

	function match_source_zone(source_zone) {
		return source_zone || '*';
	}

	// Configuration generation functions
	function generate_port_forward_rule(forward, family, source_zone, destination_zone, destination_subnet) {
		let output = [];
		let protocols = match_protocols(forward.protocol);

		uci_comment(output, '# generated by interface/firewall/forward.uc');
		uci_comment(output, '### generate port forwarding rule');
		uci_section(output, 'firewall redirect');
		uci_set_string(output, "firewall.@redirect[-1].name", `Forward port ${forward.external_port} to ${forward.internal_address}`);
		uci_set_string(output, 'firewall.@redirect[-1].family', family);
		uci_set_string(output, 'firewall.@redirect[-1].src', match_source_zone(source_zone));
		uci_set_string(output, 'firewall.@redirect[-1].dest', destination_zone);

		for (let proto in protocols)
			uci_list_string(output, 'firewall.@redirect[-1].proto', proto);

		uci_set_string(output, 'firewall.@redirect[-1].src_dport', forward.external_port);
		uci_set_string(output, 'firewall.@redirect[-1].dest_ip', ipcalc.expand_wildcard_address(forward.internal_address, destination_subnet));
		uci_set_string(output, 'firewall.@redirect[-1].dest_port', forward.internal_port);
		uci_set_string(output, 'firewall.@redirect[-1].target', 'DNAT');

		return uci_output(output);
	}
%}

{{ generate_port_forward_rule(forward, family, source_zone, destination_zone, destination_subnet) }}

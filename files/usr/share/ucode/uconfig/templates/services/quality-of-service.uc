{%
	// Constants
	const QOS_CLASSES = {
		besteffort: { ingress: 'CS0', egress: 'CS0' },
		bulk: { ingress: 'LE', egress: 'LE' },
		video: { ingress: 'AF41', egress: 'AF41' },
		voice: {
			ingress: 'CS6',
			egress: 'CS6',
			bulk_trigger_pps: 100,
			bulk_trigger_timeout: 5,
			dscp_bulk: 'CS0'
		}
	};

	const INTERFACE_DEFAULTS = {
		overhead_type: 'none',
		ingress: '1',
		egress: '1',
		mode: 'diffserv4',
		nat: '1',
		host_isolate: '1',
		autorate_ingress: '0',
		ingress_options: '',
		egress_options: '',
		options: ''
	};

	// Helper functions
	function is_upstream_interface(interface_config) {
		return interface_config.role === 'upstream';
	}

	function has_qos_bandwidth(interface_config) {
		let qos = interface_config.quality_of_service;

		return qos?.bandwidth_up && qos?.bandwidth_down;
	}

	function has_qos_interfaces() {
		for (let name, iface in state.interfaces)
			if (is_upstream_interface(iface) && has_qos_bandwidth(iface))
				return true;

		return false;
	}

	// Configuration generation functions
	function generate_qos_defaults() {
		let output = [];

		uci_comment(output, '# generated by quality-of-service.uc');
		uci_comment(output, '### generate qos defaults');
		uci_section(output, 'qosify defaults');
		uci_list_string(output, 'qosify.@defaults[-1].defaults', '/etc/qosify/*.conf');
		uci_set_string(output, 'qosify.@defaults[-1].dscp_prio', 'video');
		uci_set_string(output, 'qosify.@defaults[-1].dscp_icmp', '+besteffort');
		uci_set_string(output, 'qosify.@defaults[-1].dscp_default_udp', 'besteffort');
		uci_set_number(output, 'qosify.@defaults[-1].prio_max_avg_pkt_len', 500);

		return uci_output(output);
	}

	function generate_qos_classes() {
		let output = [];

		uci_comment(output, '### generate qos classes');

		for (let class_name, config in QOS_CLASSES) {
			uci_named_section(output, `qosify.${class_name}`, 'class');
			uci_set_string(output, `qosify.${class_name}.ingress`, config.ingress);
			uci_set_string(output, `qosify.${class_name}.egress`, config.egress);

			// Add extra voice class settings
			if (class_name === 'voice') {
				uci_set_number(output, `qosify.${class_name}.bulk_trigger_pps`, config.bulk_trigger_pps);
				uci_set_number(output, `qosify.${class_name}.bulk_trigger_timeout`, config.bulk_trigger_timeout);
				uci_set_string(output, `qosify.${class_name}.dscp_bulk`, config.dscp_bulk);
			}
		}

		return uci_output(output);
	}

	function generate_interface_qos(interface_name, interface_config) {
		if (!is_upstream_interface(interface_config) || !has_qos_bandwidth(interface_config))
			return '';

		let output = [];
		let qos = interface_config.quality_of_service;

		uci_comment(output, '### generate interface qos configuration');
		uci_named_section(output, `qosify.${interface_name}`, 'interface');
		uci_set_string(output, `qosify.${interface_name}.name`, interface_name);
		uci_set_string(output, `qosify.${interface_name}.bandwidth_up`, `${qos.bandwidth_up}mbit`);
		uci_set_string(output, `qosify.${interface_name}.bandwidth_down`, `${qos.bandwidth_down}mbit`);
		for (let key, value in INTERFACE_DEFAULTS)
			uci_set_string(output, `qosify.${interface_name}.${key}`, value);

		return uci_output(output);
	}

	function generate_all_interface_qos() {
		let output = [];

		uci_comment(output, '### generate all interface qos configurations');

		for (let name, iface in state.interfaces) {
			let config = generate_interface_qos(name, iface);
			if (config)
				push(output, config);
		}

		return uci_output(output);
	}

	// Main logic
	let enable_qos = has_qos_interfaces();
	services.set_enabled('qosify', enable_qos);
%}

## Configure QOSIFY
{{ generate_qos_defaults() }}

{{ generate_qos_classes() }}

{{ generate_all_interface_qos() }}


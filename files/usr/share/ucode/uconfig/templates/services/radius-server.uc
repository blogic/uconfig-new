{%
	// Constants
	const CERTIFICATE_PATHS = {
		ca_cert: '/etc/uconfig/certificates/ca.pem',
		cert: '/etc/uconfig/certificates/cert.pem',
		key: '/etc/uconfig/certificates/cert.key'
	};

	const RADIUS_USERS_FILE = '/etc/radius/users';
	const DEFAULTS = {
		auth_port: 1812,
		acct_port: 1813,
		secret: 'secret'
	};

	// Helper functions
	function has_radius_service() {
		return services.is_present("radius");
	}

	function auth_type_to_methods(auth_type) {
		switch (auth_type) {
		case 'password':
		case 'both':
			return ['MSCHAPV2'];
		case 'certificate':
		default:
			return [];
		}
	}

	function generate_users_file() {
		let users = radius_server?.users;

		if (!users || !length(keys(users)))
			return RADIUS_USERS_FILE;

		let users_data = {
			phase1: {
				wildcard: [
					{ name: "*", methods: ["PEAP", "TLS"] }
				]
			},
			phase2: {
				users: {}
			}
		};

		for (let name, user in users) {
			let entry = {
				methods: auth_type_to_methods(user.auth_type)
			};

			if (user.password)
				entry.password = user.password;
			if (user.vlan_id)
				entry.vlan_id = user.vlan_id;
			if (user.rate_limit_upload)
				entry.max_rate_up = user.rate_limit_upload;
			if (user.rate_limit_download)
				entry.max_rate_down = user.rate_limit_download;

			users_data.phase2.users[name] = entry;
		}

		let tmp_path = '/tmp/uconfig/radius-users.json';
		files.add_named(tmp_path, sprintf('%J\n', users_data));
		return tmp_path;
	}

	// Configuration generation functions
	function generate_radius_config() {
		let output = [];
		let users_path = generate_users_file();

		uci_comment(output, '# generated by radius-server.uc');
		uci_comment(output, '### generate radius server configuration');
		uci_section(output, 'radius radius');
		uci_set_boolean(output, 'radius.@radius[0].disabled', false);
		uci_set_boolean(output, 'radius.@radius[0].ipv6', true);
		uci_set_number(output, 'radius.@radius[0].log_level', 3);
		uci_set_string(output, 'radius.@radius[0].ca_cert', CERTIFICATE_PATHS.ca_cert);
		uci_set_string(output, 'radius.@radius[0].cert', CERTIFICATE_PATHS.cert);
		uci_set_string(output, 'radius.@radius[0].key', CERTIFICATE_PATHS.key);
		uci_set_string(output, 'radius.@radius[0].users', users_path);
		uci_set_number(output, 'radius.@radius[0].auth_port', radius_server?.auth_port ?? DEFAULTS.auth_port);
		uci_set_number(output, 'radius.@radius[0].acct_port', radius_server?.acct_port ?? DEFAULTS.acct_port);
		uci_set_string(output, 'radius.@radius[0].ipaddr', '0.0.0.0/0');
		uci_set_string(output, 'radius.@radius[0].secret', radius_server?.secret ?? DEFAULTS.secret);

		return uci_output(output);
	}

	function generate_network_interfaces(interfaces) {
		if (!length(interfaces))
			return '';

		let output = [];

		uci_comment(output, '### generate radius network interfaces');

		for (let interface in interfaces)
			uci_list_string(output, 'radius.@radius[0].network', interface.name);

		return uci_output(output);
	}

	// Main logic
	if (!has_radius_service())
		return;

	services.set_enabled("radius", true);

	let interfaces = services.lookup_interfaces("radius-server");
%}

## Configure RADIUS
{{ generate_radius_config() }}
{{ generate_network_interfaces(interfaces) }}


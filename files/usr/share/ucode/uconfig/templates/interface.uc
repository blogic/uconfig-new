# generated by interface.uc

{%
	// Constants
	const EASYMESH_MODES = ['hybrid', 'controller', 'agent'];
	const INTERFACE_ROLES = ['upstream', 'downstream'];
	const ADDRESSING_MODES = ['static', 'dhcp', 'none'];
	const BSS_MODES = ['sta', 'ap', 'mesh', 'wds-repeater', 'wds-sta', 'wds-ap'];
	const BRIDGE_DEVICES = {
		upstream: 'br-wan',
		downstream: 'br-lan'
	};
	const DEFAULT_METRICS = {
		upstream: 5,
		downstream: 10
	};
	const MESH_TEMPLATES = ['batman-adv'];
	const WDS_MODE_MAPPING = {
		'wds-repeater': ['wds-sta', 'wds-ap']
	};

	let has_downstream_relays = false;

	// is_ functions - boolean checks/validation
	function is_conflicting_interface(interface) {
		return !!interface.conflicting;
	}

	function is_station_mode(bss_modes) {
		return 'sta' in bss_modes;
	}

	function is_downstream_with_vlan(interface) {
		return interface.role == 'downstream' && ethernet.has_vlan(interface);
	}

	function is_static_upstream(interface) {
		return interface.role == 'upstream' && interface.ipv4?.addressing == 'static';
	}

	// validate_ functions - complex validation logic
	function validate_static_interface(interface) {
		if (!is_static_upstream(interface))
			return true;

		if (!interface.ipv4?.subnet || !interface.ipv4?.use_dns || !interface.ipv4?.gateway) {
			die('invalid static interface settings');
			return false;
		}

		return true;
	}

	function validate_station_bridging(interface, bss_modes, eth_ports) {
		if (!is_station_mode(bss_modes))
			return true;

		if (length(eth_ports) > 0 || length(bss_modes) > 1) {
			warn('Station mode SSIDs cannot be bridged with ethernet ports or other SSIDs, ignoring interface');
			return false;
		}

		return true;
	}

	function validate_broad_band_ports(interface, eth_ports) {
		if (!interface.broad_band?.type)
			return true;

		if (length(keys(eth_ports)) > 1) {
			warn('broad-band type requires a single port, interface has multiple');
			return false;
		}

		return true;
	}

	function validate_downstream_vlan(interface, this_vid) {
		if (!is_downstream_with_vlan(interface))
			return true;

		if (index(vlans_upstream, this_vid) < 0) {
			warn('Trying to create a downstream interface with a VLAN ID, without matching upstream interface.');
			return false;
		}

		return true;
	}

	// Early validation checks
	if (is_conflicting_interface(interface)) {
		warn('Skipping conflicting interface declaration');
		return;
	}

	/* work out the bridge vlan of this interface */
	let this_vid = interface.vlan.id || interface.vlan.dyn_id;

	/* make sure that the vlan is unique */
	for (let name, other_interface in state.interfaces) {
		/* skip if this is the same interface */
		if (other_interface == interface)
			continue;

		/* if the 'other' interface has no wired ports and a single ssid, skip it */
		if (!other_interface.ports && length(other_interface.ssids) == 1)
			continue;

		let other_vid = other_interface.vlan.id || '';

		/* if this 'this' and 'other' interface have the same role and vlan, mark 'other' as conflicting */
		if (interface.role === other_interface.role && this_vid === other_vid) {
			state.strict = true;
			error('duplicate interface: %s and %s share role "%s" with VLAN ID %d',
			      interface.name, name, interface.role, this_vid);
			other_interface.conflicting = true;
			continue;
		}

		/* if 'this' is an upstream and 'other' is a downstream interface with ipv6, relay needs to be enabled */
		if (other_interface.role == 'downstream' &&
		    other_interface.ipv6 &&
		    other_interface.ipv6.dhcpv6 &&
		    other_interface.ipv6.dhcpv6.mode == 'relay')
		    has_downstream_relays = true;
	}

	// Additional validation checks
	if (!validate_downstream_vlan(interface, this_vid))
		return;

	if (!validate_static_interface(interface))
		return;

	// normalize_ functions - data transformation
	function normalize_auto_prefix(interface_config, protocol_name, is_ipv6) {
		if (!interface_config?.subnet || !wildcard(interface_config.subnet, 'auto/*'))
			return true;

		try {
			interface_config.subnet = ipcalc.generate_prefix(state, interface_config.subnet, is_ipv6);
			return true;
		}
		catch (e) {
			warn('Unable to allocate a suitable %s prefix: %s, ignoring interface', protocol_name, e);
			return false;
		}
	}

	// Resolve auto prefixes
	if (!normalize_auto_prefix(interface.ipv4, 'IPv4', false))
		return;

	if (!normalize_auto_prefix(interface.ipv6, 'IPv6', true))
		return;

	/* gather related BSS modes and ethernet ports */
	let bss_modes = map(interface.ssids, ssid => ssid.bss_mode);
	let eth_ports = ethernet.lookup_by_interface_vlan(interface);
	let dot1x_ports = ethernet.lookup_by_select_ports(interface.ieee8021x_ports);
	ethernet.assign_port_role(eth_ports, interface.role);

	// Validate station bridging
	if (!validate_station_bridging(interface, bss_modes, eth_ports))
		return;

	if (!validate_broad_band_ports(interface, eth_ports))
		return;

	// match_ functions - value mapping/selection
	function match_bridge_device(role) {
		return BRIDGE_DEVICES[role] || 'br-lan';
	}

	function match_addressing_mode(config) {
		return config?.addressing || 'none';
	}

	function match_default_metric(role) {
		return DEFAULT_METRICS[role] || 10;
	}

	function match_bss_modes(ssid) {
		return WDS_MODE_MAPPING[ssid.bss_mode] || [ssid.bss_mode];
	}

	// Setup interface configuration
	let name = interface.name;
	let bridgedev = match_bridge_device(interface.role);
	let netdev = ethernet.calculate_name(interface);

	if (interface.broad_band?.type) {
		let port = keys(eth_ports)[0] ?? '';
		netdev = port ? (this_vid ? `${port}.${this_vid}` : port) : '';
	}

	let network = name;
	let ipv4_mode = match_addressing_mode(interface.ipv4);
	let ipv6_mode = match_addressing_mode(interface.ipv6);

	if (!interface.metric)
		interface.metric = match_default_metric(interface.role);

	/**
	 * generate the actual UCI sections
	 */

	// supports_ functions - capability checking
	function supports_batman_adv(interface) {
		return !!interface.vlan?.batman_adv;
	}

	function find_batman_interfaces() {
		let batman_adv = supports_batman_adv(interface);
		let batman_adv_master = false;

		for (let i, iface in state.interfaces) {
			if (iface.role != interface.role || iface.disable)
				continue;

			for (let k, v in iface.ssids) {
				if (v.disable)
					continue;

				if (v.template in MESH_TEMPLATES || v.bss_mode == 'mesh') {
					if (iface == interface || interface.vlan?.id)
						batman_adv = true;
					if (iface == interface)
						batman_adv_master = true;
				}
			}
		}

		return { batman_adv, batman_adv_master };
	}

	// Configuration generation functions
	function generate_batman_config(batman_result) {
		if (!batman_result.batman_adv)
			return;

		include('interface/mesh-batman-adv.uc', {
			interface, name, eth_ports, location, netdev,
			ipv4_mode, ipv6_mode, this_vid,
			batman_adv_master: batman_result.batman_adv_master
		});
	}

	function generate_bridge_config(batman_result) {
		if (!interface.ports && length(interface.ssids) == 1 && !batman_result.batman_adv) {
			// interfaces with a single ssid and no mesh do not need a bridge
			netdev = '';
		} else {
			// anything else requires a bridge-vlan
			include('interface/bridge-vlan.uc', {
				interface, netdev, eth_ports, this_vid, bridgedev,
				batman_adv: batman_result.batman_adv
			});
		}
	}

	function generate_common_config() {
		include('interface/common.uc', {
			name, this_vid, netdev,
			ipv4_mode, ipv4: interface.ipv4 || {},
			ipv6_mode, ipv6: interface.ipv6 || {},
			broad_band: interface.broad_band || {}
		});
	}

	function generate_firewall_config() {
		include('interface/firewall.uc', {
			name, ipv4_mode, ipv6_mode, networks: false
		});
	}

	function generate_ieee8021x_config() {
		if (!length(dot1x_ports))
			return;

		include('interface/ieee8021x.uc', {
			dot1x_ports, interface, eth_ports, this_vid
		});
	}

	function generate_dhcp_config() {
		if (!interface.ipv4 && !interface.ipv6)
			return;

		include('interface/dhcp.uc', {
			ipv4: interface.ipv4 || {},
			ipv6: interface.ipv6 || {},
			has_downstream_relays
		});
	}

	function generate_ports_file() {
		let ports = [];

		for (let k, v in eth_ports)
			push(ports, k);

		fs.writefile(`/tmp/uconfig/ports.${name}`, ports);
	}

	function generate_wifi_config() {
		let count = 0;
		for (let i, ssid in interface.ssids) {
			if (ssid.disable)
				continue;

			let modes = match_bss_modes(ssid);
			for (let mode in modes) {
				include('interface/ssid.uc', {
					location: location + '/ssids/' + i,
					ssid: { ...ssid, bss_mode: mode },
					count: count++,
					name,
					network
				});
			}
		}
	}

	// Main configuration generation
	if (interface.broad_band?.type) {
		generate_common_config();
		generate_firewall_config();
	} else {
		let batman_result = find_batman_interfaces();

		generate_batman_config(batman_result);
		generate_bridge_config(batman_result);
		generate_common_config();
		generate_firewall_config();
		generate_ieee8021x_config();
		generate_dhcp_config();
		generate_ports_file();
		generate_wifi_config();
	}
%}

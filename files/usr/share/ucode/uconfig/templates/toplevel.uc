# generated by toplevel.uc

{%
	// Constants
	const INTERFACE_ROLES = ['upstream', 'downstream'];
	const STATION_MODES = ['sta', 'wds-sta', 'wds-repeater'];
	const VLAN_DYNAMIC_START = 4090;
	const DEFAULT_UNIT_CONFIG = {
		leds_active: true,
		tty_login: false
	};

	// is_ functions - boolean checks/validation
	function is_valid_uuid(uuid) {
		return !!uuid;
	}

	function is_upstream_interface(interface) {
		return interface.role == 'upstream';
	}

	function is_downstream_interface(interface) {
		return interface.role == 'downstream';
	}

	function is_disabled_interface(interface) {
		return !!interface.disable;
	}

	function is_station_mode(bss_mode) {
		return bss_mode in STATION_MODES;
	}

	function is_auto_channel(radio) {
		return !radio.channel || radio.channel == 'auto';
	}

	// validate_ functions - complex validation logic
	function validate_uuid() {
		if (!is_valid_uuid(state.uuid)) {
			state.strict = true;
			error('Configuration must contain a valid UUID. Rejecting whole file');
			return false;
		}

		return true;
	}

	function validate_upstream_interfaces() {
		let upstream;

		for (let i, interface in state.interfaces) {
			if (!is_upstream_interface(interface))
				continue;
			upstream = interface;
		}

		if (!upstream) {
			state.strict = true;
			error('Configuration must contain at least one valid upstream interface. Rejecting whole file');
			return false;
		}

		return true;
	}

	// normalize_ functions - data transformation
	function normalize_interfaces() {
		for (let i, interface in state.interfaces)
			if (is_disabled_interface(interface))
				delete state.interfaces[i];
	}

	function normalize_interface_names() {
		for (let name, interface in state.interfaces)
			interface.name = name;
	}

	function normalize_interface_indexes() {
		let idx = 0;

		for (let name, interface in state.interfaces)
			interface.index = idx++;
	}

	// Early validation and normalization
	if (!validate_uuid())
		return;

	normalize_interfaces();

	if (!validate_upstream_interfaces())
		return;

	function validate_port_conflicts() {
		let wan_ports = [];

		for (let i, interface in state.interfaces) {
			if (!is_upstream_interface(interface))
				continue;

			let eth_ports = ethernet.lookup_by_interface_vlan(interface);
			for (let port in keys(eth_ports)) {
				if (ethernet.port_vlan(interface, eth_ports[port]))
					continue;

				if (port in wan_ports) {
					state.strict = true;
					error('duplicate usage of un-tagged ports: ' + port);
					return false;
				}
				push(wan_ports, port);
			}
		}

		return wan_ports;
	}

	let wan_ports = validate_port_conflicts();
	if (!wan_ports)
		return;

	function normalize_ieee8021x_ports() {
		for (let i, interface in state.interfaces) {
			let ports = ethernet.lookup_by_select_ports(interface.ieee8021x_ports);
			for (let port in ports)
				ethernet.reserve_port(port);
		}
	}

	normalize_ieee8021x_ports();
	normalize_interface_names();
	normalize_interface_indexes();

	function collect_vlans() {
		let vlans = [];
		let vlans_upstream = [];

		for (let name, interface in state.interfaces) {
			if (ethernet.has_vlan(interface)) {
				push(vlans, interface.vlan.id);
				if (is_upstream_interface(interface))
					push(vlans_upstream, interface.vlan.id);
			} else {
				interface.vlan ??= { };
				interface.vlan.id = 0;
			}

			for (let vlan in interface.vlan?.trunks)
				push(vlans_upstream, vlan);
		}

		return { vlans, vlans_upstream };
	}

	function get_next_free_vlan_id(vlans, current_vid) {
		while (current_vid > 0 && current_vid in vlans)
			current_vid--;
		if (current_vid <= 0)
			die('No free VLAN IDs available');
		return current_vid;
	}

	function assign_dynamic_vlans(vlans) {
		let vid = VLAN_DYNAMIC_START;

		for (let i, interface in state.interfaces) {
			if (!interface.vlan.id) {
				interface.vlan.dyn_id = vid;
				vlans[vid] = true;
				vid = get_next_free_vlan_id(vlans, vid - 1);
			}
		}
	}

	let vlan_data = collect_vlans();
	assign_dynamic_vlans(vlan_data.vlans);

	function normalize_country_code() {
		// Country code is set from timezone lookup in unit.uc
		// Only fall back to board default if not already set
		if (!state.country_code && board.wlan.defaults?.country) {
			warn('using board default country code\n');
			state.country_code = board.wlan.defaults.country;
		}
	}

	function force_auto_channel_for_stations() {
		for (let i, radio in state.radios) {
			if (is_auto_channel(radio))
				continue;

			for (let j, iface in state.interfaces) {
				for (let s, ssid in iface.ssids) {
					if (is_station_mode(ssid.bss_mode)) {
						warn('Forcing Auto-Channel as a STA interface is present');
						delete radio.channel;
						break;
					}
				}
			}
		}
	}

	normalize_country_code();
	force_auto_channel_for_stations();

	// Configuration generation functions
	function generate_base_config() {
		include('base.uc');
	}

	function generate_unit_config() {
		state.unit ??= DEFAULT_UNIT_CONFIG;
		include('unit.uc', { location: '/unit', unit: state.unit });
	}

	function generate_services_config() {
		state.services ??= {};
		for (let service in services.lookup_services()) {
			let service_name = replace(service, '-', '_');
			tryinclude('services/' + service + '.uc', {
				location: '/services/' + service,
				[service_name]: state.services[service_name] || {},
				state,
			});
		}
	}

	function generate_ethernet_config() {
		tryinclude('ethernet.uc', { location: '/ethernet/', wan_ports });
	}

	function generate_radio_config() {
		for (let phy_name, radio in state.radios)
			tryinclude('radio.uc', {
				location: '/radios/' + phy_name,
				phy_name,
				radio
			});
	}

	function iterate_interfaces(role, vlans_upstream) {
		for (let i, interface in state.interfaces) {
			if (interface.role != role)
				continue;
			include('interface.uc', {
				location: '/interfaces/' + i,
				interface,
				vlans_upstream: vlans_upstream
			});
		}
	}

	function generate_interface_config() {
		iterate_interfaces("upstream", vlan_data.vlans_upstream);
		iterate_interfaces("downstream", vlan_data.vlans_upstream);
	}

	// Main configuration generation
	generate_base_config();
	generate_unit_config();
	generate_services_config();
	generate_ethernet_config();
	generate_radio_config();
	generate_interface_config();
%}


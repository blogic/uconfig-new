{%
	function needs_upstream_bridge() {
		for (let name, iface in state.interfaces)
			if (iface.role == 'upstream' && !iface.broad_band?.type)
				return true;
		return false;
	}

	// Configuration generation functions ordered by purpose

	function generate_loopback_config() {
		let output = [];

		uci_comment(output, '# generated by base.uc');
		uci_comment(output, '### generate loopback interface');
		uci_named_section(output, 'network.loopback', 'interface');
		uci_set_string(output, 'network.loopback.ifname', 'lo');
		uci_set_string(output, 'network.loopback.proto', 'static');
		uci_set_string(output, 'network.loopback.ipaddr', '127.0.0.1');
		uci_set_string(output, 'network.loopback.netmask', '255.0.0.0');

		return uci_output(output);
	}

	function generate_upstream_bridge() {
		let output = [];

		uci_comment(output, '### generate upstream bridge');
		uci_named_section(output, 'network.wan_bridge', 'device');
		uci_set_string(output, 'network.@device[-1].name', 'br-wan');
		uci_set_string(output, 'network.@device[-1].type', 'bridge');
		uci_set_boolean(output, 'network.@device[-1].igmp_snooping', true);
		uci_set_boolean(output, 'network.@device[-1].multicast_to_unicast', true);

		return uci_output(output);
	}

	function generate_downstream_bridge() {
		let output = [];

		uci_comment(output, '### generate downstream bridge');
		uci_named_section(output, 'network.lan_bridge', 'device');
		uci_set_string(output, 'network.@device[-1].name', 'br-lan');
		uci_set_string(output, 'network.@device[-1].type', 'bridge');
		uci_set_boolean(output, 'network.@device[-1].igmp_snooping', true);
		uci_set_boolean(output, 'network.@device[-1].multicast_to_unicast', true);

		return uci_output(output);
	}

	function generate_wan_interface() {
		let output = [];

		uci_comment(output, '### generate unmanaged wan interface');
		uci_named_section(output, 'network.wan_none', 'interface');
		uci_set_string(output, 'network.wan_none.ifname', 'br-wan');
		uci_set_string(output, 'network.wan_none.proto', 'none');

		return uci_output(output);
	}

	function generate_firewall_offload() {
		let offload = state.offload?.firewall ?? 'software';
		let output = [];

		uci_comment(output, '### generate firewall offload settings');
		if (offload == 'none') {
			uci_set_number(output, 'firewall.@defaults[0].flow_offloading', 0);
		} else if (offload == 'hardware') {
			uci_set_number(output, 'firewall.@defaults[0].flow_offloading', 1);
			uci_set_number(output, 'firewall.@defaults[0].flow_offloading_hw', 1);
		} else {
			uci_set_number(output, 'firewall.@defaults[0].flow_offloading', 1);
			uci_set_number(output, 'firewall.@defaults[0].flow_offloading_hw', 0);
		}

		return uci_output(output);
	}

	function generate_mac_address(interface_name, interface_device, mac_address) {
		let output = [];

		uci_comment(output, `### generate mac address for ${interface_name}`);
		uci_section(output, 'network device');
		uci_set_string(output, 'network.@device[-1].name', interface_device);
		uci_set_string(output, 'network.@device[-1].macaddr', mac_address);

		return uci_output(output);
	}
%}

## Basic configuration
{{ generate_loopback_config() }}

## Bridge configuration
{%	if (needs_upstream_bridge()): %}
{{ generate_upstream_bridge() }}
{%	endif %}
{{ generate_downstream_bridge() }}

{%	if (needs_upstream_bridge()): %}
## WAN interface
{{ generate_wan_interface() }}
{%	endif %}

## Firewall offload configuration
{{ generate_firewall_offload() }}

## MAC address configuration
{%	for (let k, v in board_json.macaddr): %}
{{ generate_mac_address(k, board_json.network[k][0], v) }}
{%	endfor %}


#!/usr/bin/ucode

'use strict';

import * as ubus from 'ubus';
import * as uloop from 'uloop';
import * as nl80211 from 'nl80211';
import * as rtnl from 'rtnl';
import * as fs from 'fs';
import { md5 } from 'digest';

let capab = json(fs.readfile('/etc/uconfig/capabilities.json')) ?? {};

uloop.init();

let hostapd = {};
let hapd_subscriber;
let log_subscriber;
let dnsmasq_subscriber;
let ratelimit = false;
let wan_ports = capab.network?.wan ?? [];
let carrier = {};
let events = [];
let event_count = 0;
let ubus_event;
let max_events = 100;

const DRIVER_MAP = {
	nl80211: 'wireless',
	wired: 'wired',
};

const OP_CLASS_RANGES = {
	'2G': { min: 81, max: 84 },
	'5G': { min: 115, max: 130 },
	'6G': { min: 133, max: 136 },
};

const BAND_UNKNOWN = 'unknown';

const EVENT_OBJECT = {
	CLIENT: 'client',
	WIFI: 'wifi',
	SSH: 'ssh',
	CARRIER: 'carrier',
	DHCP: 'dhcp',
};

const EVENT_VERB = {
	JOIN: 'join',
	LEAVE: 'leave',
	KEY_MISMATCH: 'key-mismatch',
	CHANNEL_SWITCH: 'channel-switch',
	START: 'start',
	STOP: 'stop',
	EVENT: 'event',
	UP: 'up',
	DOWN: 'down',
};

function event(object, verb, payload) {
	let event = object;
	let local_event = event && object && payload;
	if (local_event)
		event = { object, verb, time: time(), ...payload };
	printf('event -> %s.%s %J\n', event.object, event.verb, event);
	events[event_count % max_events] = event;
	event_count++;

	if (ubus_event)
		ubus_event.notify('event', event);
}

let handlers;
handlers = {
	'sta-authorized': function(notify, hapd) {
		let msg = {
			medium: DRIVER_MAP[hapd.driver] || 'unknown',
			mac: notify.data.address
		};
		for (let key in [ 'ssid', 'bssid', 'ifname', 'channel', 'band', 'rate-limit' ])
			if (exists(hapd, key))
				msg[key] = hapd[key];
		for (let key in [ 'rate-limit', 'vlan' ])
			if (exists(notify.data, key))
				msg[key] = notify.data[key];

		event(EVENT_OBJECT.CLIENT, EVENT_VERB.JOIN, msg);
		
		if (ratelimit) {
			msg = {
				device: (notify.data.vlan && notify.data.vlan != 0)
					? notify.data.ifname + "-v" + notify.data.vlan
					: notify.data.ifname,
				address: notify.data.address,
			};
			if (notify.data['rate-limit']) {
				msg.rate_ingress = `${notify.data['rate-limit'][0]}mbit`;
				msg.rate_egress = `${notify.data['rate-limit'][1]}mbit`;
			} else
				msg.defaults = md5(hapd.ssid);
			ubus.call('ratelimit', 'client_set', msg);
			let err = ubus.error(true);
			if (err && err != 0)
				printf('Failed to set ratelimit for client %s: %s\n', msg.address, ubus.error());
		}
	},

	disassoc: function(notify, hapd) {
		if (ratelimit) {
			let msg = {
				address: notify.data.address,
				device: hapd.ifname,
			};
			ubus.call('ratelimit', 'client_delete', msg);
			let err = ubus.error(true);
			if (err && err != 0)
				printf('Failed to delete ratelimit for client %s: %s\n', msg.address, ubus.error());
		}
	},

	'key-mismatch': function(notify, hapd) {
		event(EVENT_OBJECT.CLIENT, EVENT_VERB.KEY_MISMATCH, {
			mac: notify.data.address,
			ssid: hapd.ssid,
			bssid: hapd.bssid,
		});
	},

	'channel-switch': function(notify, hapd) {
		event(EVENT_OBJECT.WIFI, EVENT_VERB.CHANNEL_SWITCH, notify.data);
	}, 

	vlan_add: function(notify) {
		for (let wan in wan_ports) {
			let msg = {
				name: wan,
				vlan: [ `${notify.data.vlan_id}:t` ]
			};
			ubus.call('network.interface.wan_none', 'add_device', msg);
			let err = ubus.error(true);
			if (err && err != 0)
				printf('Failed to add VLAN %s to device %s: %s\n', notify.data.vlan_id, wan, ubus.error());
		}

		let msg = {
			name: notify.data.ifname,
			'link-ext': true,
			vlan: [ `${notify.data.vlan_id}:u` ]
		};
		ubus.call('network.interface.wan_none', 'add_device', msg);
		let err = ubus.error(true);
		if (err && err != 0)
			printf('Failed to add VLAN %s to device %s: %s\n', notify.data.vlan_id, notify.data.ifname, ubus.error());
	},

	vlan_remove: function(notify) {
		if (ratelimit) {
			let msg = {
				device: notify.data.ifname,
			};
			ubus.call('ratelimit', 'device_delete', msg);
			let err = ubus.error(true);
			if (err && err != 0)
				printf('Failed to delete ratelimit for device %s: %s\n', notify.data.ifname, ubus.error());
		}
	},
};


function hapd_subscriber_notify_cb(notify) {
	if (notify.type == 'probe')
		return 0;
	let handler = handlers[notify.type];
	printf('hapd event -> %s %J\n', notify.type, notify.data);
	if (!handler)
		return 0;
	let hapd = hostapd[notify.data.ifname];
	handler(notify, hapd);

	return 0;
}

function hostapd_event(ifname, type) {
	let payload = {};
	if (!(ifname in hostapd) || wildcard(ifname, 'eth*'))
		return;
	for (let p in [ 'ssid', 'bssid', 'channel', 'band' ])
		payload[p] = hostapd[ifname][p];

	event(EVENT_OBJECT.WIFI, type, payload);
}

function hostapd_add(path, obj) {
	let ifname = obj[1];

	hostapd[ifname] = ubus.call(path, 'get_status');
	if (!hostapd[ifname]) {
		let err = ubus.error();
		printf('Failed to get status for hostapd %s: %s\n', path, err || 'no data returned');
		return;
	}
	hostapd[ifname].ifname = ifname;
	hostapd[ifname].path = path;

	let op_class = hostapd[ifname].op_class;
	let band = BAND_UNKNOWN;
	for (let band_name, range in OP_CLASS_RANGES) {
		if (op_class >= range.min && op_class <= range.max) {
			band = band_name;
			break;
		}
	}
	hostapd[ifname].band = band;

	hostapd_event(ifname, EVENT_VERB.START);

	printf('adding %s\n', path);
	hapd_subscriber.subscribe(path);
}

function hostapd_remove(path, obj) {
	let ifname = obj[1];
	hostapd_event(ifname, EVENT_VERB.STOP);
	printf('removing %s\n', path);
	delete hostapd[ifname];
	if (ratelimit) {
		let msg = {
			device: ifname,
		};
		ubus.call('ratelimit', 'device_delete', msg);
		let err = ubus.error(true);
		if (err && err != 0)
			printf('Failed to delete ratelimit for device %s: %s\n', ifname, ubus.error());
	}
}

function hapd_subscriber_remove_cb(remove) {
	printf('remove: %.J\n', remove);
}

function log_subscriber_notify_cb(notify) {
	let msg = split(notify.data.msg, ': ', 2);
	let daemon = split(msg[0], '[')[0];

	switch(daemon) {
	case 'dropbear':
		event(EVENT_OBJECT.SSH, EVENT_VERB.EVENT, { msg: msg[1] });
		break;
	}
}

function log_subscriber_remove_cb(remove) {
	printf('log remove: %.J\n', remove);
}

function dnsmasq_subscriber_notify_cb(notify) {
	let msg = split(notify.type, '.');
	if (msg[0] != 'dhcp')
		return;
	event(EVENT_OBJECT.DHCP, msg[1], notify.data);
}

function dnsmasq_subscriber_remove_cb(remove) {
	printf('dnsmasq remove: %.J\n', remove);
}

function unsub_object(add, id, path) {
	let object = split(path, '.');

	switch (path) {
	case 'ratelimit':
		ratelimit = add;
		break;
	case 'log':
		printf('adding %s\n', path);
		log_subscriber.subscribe(path);
		break;
	case 'dnsmasq':
		printf('adding %s\n', path);
		dnsmasq_subscriber.subscribe(path);
		break;
	}
	if (object[0] == 'hostapd' && object[1]) {
		if (add)
			hostapd_add(path, object);
		else
			hostapd_remove(path, object);
	}
}

function listener_cb(event, payload) {
	unsub_object(event == 'ubus.object.add', payload.id, payload.path);
}

function nl_cb(msg) {
	let mac = msg.msg.mac;
	let sinfo = msg.msg.sta_info;
	let payload = {
		mac,
		tx_bytes: sinfo.tx_bytes64,
		rx_bytes: sinfo.rx_bytes64,
		tx_packets: sinfo.tx_packets,
		rx_packets: sinfo.rx_packets,
		connected_time: sinfo.connected_time,
	};
	event(EVENT_OBJECT.CLIENT, EVENT_VERB.LEAVE, payload);
}

function ifname_lookup(prefix, ifname, list) {
	let idx = index(list, ifname);
	if (idx < 0)
		return;
	return prefix + ((length(list) > 1) ? (idx + 1) : '');
}

function rtnl_cb(msg) {
	if (!exists(msg.msg, "carrier"))
		return;

	let name = ifname_lookup('LAN', msg.msg?.ifname, capab.network?.lan);
	if (!name)
		name = ifname_lookup('WAN', msg.msg?.ifname, capab.network?.wan);
	if (name) {
		let verb = msg.msg.carrier ? EVENT_VERB.UP : EVENT_VERB.DOWN;
		if (carrier[name] == verb)
			return;
		carrier[name] = verb;
		event(EVENT_OBJECT.CARRIER, verb, { name });
	}
}

let ubus_methods = {
	event: {
		call: function(req) {
			if (!req.args.object || !req.args.payload)
				return ubus.STATUS_INVALID_ARGUMENT;

			event(req.args.object, req.args.verb, req.args.payload);
			return 0;
		},
		args: {
			object:"",
			verb:"",
			payload:{},
		}
	},

	log: {
		call: function(req) {
			return { log: filter(events, (e) => e != null) };
		},
		args: {

		}
	},
};

hapd_subscriber = ubus.subscriber(hapd_subscriber_notify_cb, hapd_subscriber_remove_cb);
log_subscriber = ubus.subscriber(log_subscriber_notify_cb, log_subscriber_remove_cb);
dnsmasq_subscriber = ubus.subscriber(dnsmasq_subscriber_notify_cb, dnsmasq_subscriber_remove_cb);

let list = ubus.list();
for (let k, path in list)
	unsub_object(true, 0, path);

ubus.listener('ubus.object.add', listener_cb);
ubus.listener('ubus.object.remove', listener_cb);

ubus_event = ubus.publish("event", ubus_methods);

nl80211.listener(nl_cb, [ nl80211.const.NL80211_CMD_DEL_STATION ]);
rtnl.listener(rtnl_cb, null, [ rtnl.const.RTNLGRP_LINK ]);

uloop.run();
uloop.done();
